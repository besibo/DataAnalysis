# (Ar)ranger des données avec `tidyr` {#sec-tidyr}

## Préambule

Dans la @sec-objects, nous avons introduit le concept de tableaux de données ou `data.frame` dans `R`. Il s'agit d'une représentation rectangulaire des données, à la manière d'un tableur, dans laquelle les lignes correspondent aux observations et les colonnes correspondent à des variables décrivant chaque observation. 

Dans ce chapitre, nous allons aller plus loin en présentant le concept de **tidy data**, ou "données nettes/rangées/soignées/ordonnées". Vous verrez que l'idée d'avoir des données stockées dans un format "net" va plus loin que la simple définition usuelle que le terme "rangé" peut avoir lorsque les données sont simplement bien organisées dans un tableur. Nous définirons le terme "tidy data" de manière plus rigoureuse, en établissant un ensemble de règles permettant de stocker les données correctement afin de rendre plus aisées les analyses statistiques et les représentations graphiques.

Jusqu'à maintenant, vous avez utilisé des données qui étaient déjà dans ce format (c'est le cas des données contenues dans `penguins`, ou dans `diamonds` par exemple). Pourtant, la plupart du temps, les données que vous manipulerez dans `R` seront importées depuis un tableur dans lequel vous ou vos collaborateurs en aurez fait la saisie. S'assurer que les données importées manuellement dans `R` sont correctement "nettoyées" et mises en forme de "tidy data" est indispensable pour éviter les problèmes lors de la réalisation de graphiques (voir @sec-viz) comme lors de la manipulation des données pour en tirer de l'information statistique pertinente (ce que nous verrons au @sec-wrangling).


## Pré-requis {#sec-prerek}

Dans ce chapitre, nous aurons besoin des packages suivants :

```{r}
#| message: false
#| warning: false

library(tidyverse)
library(palmerpenguins)
library(readxl)  # la dernière lettre est un "L" minuscule, pas le chiffre 1...
```

Comme d'habitude, si vous recevez des messages d'erreur, c'est probablement parce que le package que vous essayez de charger en mémoire n'a pas été installé au préalable. Consultez la @sec-packages si vous ne savez plus comment procéder.

Outre ces packages classiques, nous aurons aussi besoin du package `EDAWR` qui n'est pas disponible sur les serveurs habituels de `R`. Pour l'installer, on procède de la façon suivante : 

1. Installez et chargez en mémoire le package `remotes` :

```{r}
#| eval: false

install.packages("remotes")
library(remotes)
```

2. Installez le package `EDAWR` grâce à la fonction `install_github()` du package `remotes` qui va chercher le package sur le site https://github.com :

```{r}
#| eval: false

install_github("rstudio/EDAWR")
```

Attention, sur les ordinateurs de l'université cette procédure ne fonctionne pas toujours. Si vous rencontrez des difficultés, suivez les instructions décrites à la fin de cette @sec-prerek.

3. Chargez le package `EDAWR` de la façon habituelle :
```{r}
#| eval: false

library(EDAWR)
```

```{r}
#| echo: false
#| message: false
#| warning: false
# if (!("remotes" %in% installed.packages())) {
#   install.packages("remotes")
# }
# library(remotes)
# if (!("EDAWR" %in% installed.packages())) {
#   install_github("rstudio/EDAWR")
# }
# library(EDAWR)

load("data/cases.rdata")
load("data/population.rdata")
load("data/rates.rdata")
load("data/storms.rdata")
```

Le package `EDAWR` contient plusieurs jeux de données dont nous allons nous servir pour illustrer les questions liées au format des tableaux de données. Pour en avoir la liste, vous pouvez taper :

```{r}
#| eval: false
data(package = "EDAWR")
```


**En cas de problème pour installer le package `EDAWR` sur les ordinateurs de l'université.**

Vous pouvez télécharger manuellement les 4 jeux de données dont nous aurons besoin grâce à ces 4 liens :

- [cases](data/cases.rdata)
- [population](data/population.rdata)
- [rates](data/rates.rdata)
- [storms](data/storms.rdata)

Une fois téléchargés, les données contenues dans ces 4 fichiers peuvent être importées dans `RStudio` en cliquant sur `File > Open File...`, puis en sélectionnant un à un chacun des fichiers. Pour chaque fichier un nouvel objet doit apparaître dans votre environnement de travail (onglet `Environnement`, dans le panneau en haut à droite de `RStudio`). L'inconvénient de cette méthode est que les fichiers d'aide de ces jeux de données ne seront pas disponibles dans `RStudio.` Vous pouvez toutefois en consulter une version brute (non mise en forme) [en cliquant ici](https://github.com/rstudio/EDAWR/tree/master/man).



## C'est quoi des "tidy data" ?

Les "tidy data" (nous les appellerons "données rangées" dans la suite de ce livre), sont des données qui respectent un format standardisé. En particulier :

- Chaque variable est dans une colonne unique.
- Chaque colonne contient une unique variable.
- Chaque ligne correspond à une observation pour chaque variable.
- Les cellules du tableau représentent les valeurs de chaque observation pour chaque variable.

```{r}
#| label: fig-tidyschema
#| echo: false
#| out-width: '90%'
#| fig-align: 'center'
#| warning: false
#| fig-cap: "La définition des 'données rangées', d'après [http://r4ds.had.co.nz/tidy-data.html](http://r4ds.had.co.nz/tidy-data.html)."

knitr::include_graphics('images/tidy.png')
```

Malheureusement, les données peuvent être présentées sous de nombreux formats qui ne respectent pas ces règles de base. La modification des tableaux est donc souvent un préambule nécessaire à toute analyse statistique ou représentation graphique.

Par exemple, examinez le tableau `cases` du package `EDAWR`, qui présente le nombre de cas de tuberculose dans 3 pays en 2011, 2012 et 2013.

```{r}
cases
```
Dans ce tableau, essayez d'identifier quelles sont les variables en présence. Indice, vous devriez en trouver 3.

Essayez d'identifier également où se trouvent ces variables.

Pour ma part, je compte les 3 variables suivantes :

1. `country` : qui indique les pays dans lesquels les cas de tuberculose ont été dénombrés. Cette variable occupe la première colonne du tableau.
2. La seconde variable est l'année, qui peut prendre les valeurs 2011, 2012 ou 2013. Cette variable occupe la ligne des titres des 3 colonnes de droite du tableau.
3. Et enfin, la troisième variable est le nombre de cas de tuberculose observés dans chaque pays et chaque année. Cette troisième variable occupe 3 lignes et 3 colonnes du tableau.

Autrement dit, les variables peuvent être visualisées de la façon suivante :

```{r}
#| label: fig-gather
#| echo: false
#| out-width: '50%'
#| fig-align: 'center'
#| warning: false
#| fig-cap: "Position des variables dans le tableau `cases` du package `EDAWR`."

knitr::include_graphics('images/gather.png')
```

Donc même si nous disposons ici d'un tableau rectangulaire classique, nous sommes bien loin du format des données rangées.

### La fonction `pivot_longer()`

Afin de transformer les données non rangées du tableau `cases` en données rangées, nous allons utiliser la fonction `pivot_longer()` du package `tidyr`. Avant d'aller plus loin, essayez d'imaginer à quoi le tableau rangé devrait ressembler.

La fonction `pivot_longer()` prend 4 arguments :

1. `data` : le nom du tableau de données que l'on souhaite "ranger".
2. `cols` : La liste des colonnes du tableau initial que l'on souhaite rassembler en 2 nouvelles variables. Ici, les colonnes 2, 3 et 4 (on pourra les noter `2:4` ou, en utilisant leur nom, `"2011":"2013"`).
3. `names_to` : le nom d'une nouvelle variable qui contiendra les en-têtes des colonnes qui constituent la seconde variable. Ici, nous nommerons cette seconde variable `year` car elle devra contenir les années 2011, 2012 et 2013.
4. `values_to` : le nom d'une nouvelle variable qui contiendra les informations correspondant à la troisième variable identifiée plus haut. Nous appellerons cette variables `n_cases` car elle contiendra les nombres de cas de tuberculose (7000, 5800, 15000, etc).

```{r}
#| tidy: false

pivot_longer(data = cases, 
             cols = `2011`:`2013`, 
             names_to = "year", 
             values_to = "n_cases")
```

Nous avons bien transformé le tableau de départ en un "tableau rangé" : chacune de nos 3 variables se trouve dans une unique colone, et chaque ligne correspond à une observation pour chacune de ces 3 variables. Comme d'habitude, si nous souhaitons pouvoir utiliser ce nouveau tableau, il faut lui donner un nom :

```{r}
#| tidy: false

cases_tidy <- pivot_longer(data = cases, 
                           cols = `2011`:`2013`, 
                           names_to = "year", 
                           values_to = "n_cases")
```

Il nous est maintenant plus facile de manipuler ces données pour en tirer de l'information, grâce à des analyses statistiques ou des représentations graphiques :

```{r}
#| label: fig-casesbarplot
#| tidy: false
#| warning: false
#| fig-cap: "Évolution du nombre de cas de tuberculose dans 3 pays, de 2011 à 2013."

ggplot(cases_tidy, aes(x = country, y = n_cases, fill = year)) +
  geom_col(position = "dodge", color = "black") +
  scale_fill_brewer(palette = "Accent") +
  theme_minimal() +
  labs(x = "Pays",
       y = "Nombre de cas",
       fill = "Année",
       title = "Évolution du nombre de cas de tuberculose entre 2011 et 2013",
       subtitle = "DE : Allemagne, FR : France, US : États-Unis")
```

On constate ici qu'entre 2011 et 2013, le nombre de cas de tuberculose a légèrement augmenté en Allemagne, est resté stable en France, et a diminué aux États-Unis.

Notez ici que la variable `year` de notre nouveau tableau est considérée comme une variable de type "chaîne de caractères" et non comme une variable numérique. On peut le voir en affichant notre tableau en tapant son nom, ou en utilisant la fonction `str()` déjà décrite plus tôt :

```{r}
str(cases_tidy)
```

C'est le comportement par défaut de la fonction `pivot_longer()` : les anciens titres de colonnes sont convertis en chaînes de caractères. Si ce comportement n'est pas souhaitable, il y a 2 alternatives possibles :

1. utiliser les arguments `names_transform` et/ou `values_transform` de la fonction `pivot_longer()`. Cela permet de spécifier comment transformer les variables nouvellement créées au moment de leur création.
2. utiliser les fonctions `mutate()` et `as.numeric()` ou `as.integer()` après avoir modifié le tableau de départ avec `pivot_longer()`. Cette façon de faire sera décrite dans la @sec-mutate.


```{r}
#| tidy: false

# On commence par afficher `cases`
cases 

# On utilise ensuite pivot_longer() avec l'argument 
# names_transform pour transformer year en variable entière
pivot_longer(data = cases, 
             cols = `2011`:`2013`, 
             names_to = "year", 
             values_to = "n_cases",
             names_transform = list(year = as.integer))
```
On voit ici que la variable `year` est maintenant une colonne numérique (`<int>` : nombres entiers), et non plus une variable de type "character". En utilisant `as.numeric()` au lieu de `as.integer()`, on aurait transformé la variable `year` en `<dbl>` (nombre réel au lieu de nombre entier), ce qui ici, reviendrait exactement au même.

De la même façon, on peut avoir besoin de présenter la colonne `year` sous la forme d'un facteur :

```{r}
#| tidy: false

pivot_longer(data = cases, 
             cols = `2011`:`2013`, 
             names_to = "year", 
             values_to = "n_cases",
             names_transform = list(year = as.factor))
```

### La fonction `pivot_wider()` {#sec-spread}

La fonction `pivot_wider()` permet de réaliser l'opération inverse de `pivot_longer()`. Elle "disperse" une unique colonne catégorielle en plusieurs colonnes, le tableau obtenu est donc plus large ("wider") que le tableau de départ.

Reprenons par exemple notre tableau `cases_tidy` :

```{r}
cases_tidy
```

La fonction `pivot_wider()` prend 3 arguments :

1. Le nom du tableau contenant les données (ici, `cases_tidy`).
2. `names_from` : le nom de la variable contenant les catégories qui devront être transformées en colonnes (ici, `year`).
3. `values_from` : le nom de la variable contenant les valeurs qui devront remplir les nouvelles colonnes (ici, `n_cases`).

```{r}
#| tidy: false

pivot_wider(data = cases_tidy, 
            names_from = year, 
            values_from = n_cases)
```

Cette fonction sera donc rarement utilisée puisqu'elle ne permet pas d'obtenir des "tableaux rangés". Toutefois, elle pourra vous être utile dans 2 situations : 

1. pour mettre en forme des données appariées afin de réaliser certains tests statistiques et graphiques spécifiques (plus de détails à ce sujet dans le @sec-moy2)
2. pour présenter des résultats sous forme synthétique. Prenons un exemple avec le jeu de données `penguins`. Imaginons que vous deviez créer un tableau `resum` présentant les effectifs de mâles et de femelles des 3 espèces de manchots. Une possibilité serait de taper ceci :

```{r}
#| tidy: false

resum <- penguins |> 
  group_by(species, sex) |> 
  count()
resum
```

Les commandes permettant de produire ce tableau seront expliquées dans le @sec-wrangling. On peut cependant constater ici que ce tableau contient 8 lignes et 3 colonnes. Il s'agit bien d'un "tableau rangé" parfaitement adapté pour faire des statistiques et des visualisations graphiques, mais son format n'est pas terrible si notre objectif est de le faire figurer dans un rapport. La solution : utiliser `pivot_wider()` :

```{r}
#| tidy: false

resum_large <- pivot_wider(resum, 
            names_from = sex, 
            values_from = n)

resum_large
```

Ce nouveau tableau contient maintenant 3 lignes (une par espèce), et 4 colonnes : une pour la variable `species`, et 3 pour la variable `sex`, soit une colonne pour les femelles, une colonne pour les mâles, et une pour les individus dont le sexe est inconnu (`` `NA` ``). On parle de tableau au **format large** (par opposition au "tableau rangé", dit "format long"). Cela rend la présentation dans un rapport plus aisée. 

Notez également que pour l'espèce Chinstrap, tous les individus ont été sexés correctement. Le tableau au format large devrait donc indiquer `0` au lieu de `NA` dans la indique quatrième colonne de la deuxième ligne. En effet, `NA` signifie "Not Available", autrement dit : données manquantes. Ici, il ne s'agit pas du tout d'une données manquantes : cela signifie simplement qu'aucun individu de l'espèce Chinstrap ne possède un sexe inconnu. Nous pouvons donc indiquer à `R` quelle valeur utiliser pour les catégories qui ne sont pas représentées dans le tableau de départ grâce à l'argument `values_fill` :

```{r}
#| tidy: false

pivot_wider(resum, 
            names_from = sex, 
            values_from = n, 
            values_fill = 0)
```

D'autres arguments existent. **Je vous encourage vivement** à consulter l'aide des fonctions `pivot_longer()` et `pivot_wider()` et à faire des essais.


### Les fonctions `separate()` et `unite()`

Ces fonctions sont complémentaires : tout comme `pivot_longer()` et `pivot_wider()`, elles effectuent 2 opérations opposées. Reprenons le jeu de données `cases_tidy` :

```{r}
cases_tidy
```

Imaginons que nous ayons besoin de séparer les données de la colonne `year` en 2 variables : le siècle d'une part, et l'année d'autre part. La fonction `separate()` permet de faire exactement cela :

```{r}
separate(cases_tidy, year, into = c("century", "year"), sep = 2)
```

1. Le premier argument est le nom du tableau de données.
2. Le second argument est la variable que l'on souhaite scinder en plusieurs morceaux.
3. `into` est un vecteur qui contient le nom des nouvelles colonnes à créer
4. `sep` peut prendre plusieurs formes. Lorsqu'on utilise un nombre, ce nombre correspond à la position de la coupure dans la variable d'origine. Ici, la variable d'origine a été coupée après le second caractère. Il est aussi possible d'utiliser des nombres négatifs : `R` compte alors à partir de la droite au lieu de compter à partir de la gauche. Enfin, il est aussi possible d'utiliser un symbole. Par exemple, certaines variables contiennent des tirets `-` ou des slashs `\`. Utiliser ces caractères en guise de séparateur permet de couper les variables à ce niveau là. Nous en verrons un exemple plus tard.

Notez ici que les 2 nouvelles variables sont de type `<chr>`. Si nous souhaitons que ces variables soient considérées comme numériques, nous devons ajouter un argument lorsque nous utilisons `separate()` :

```{r}
cases_split <- separate(cases_tidy, 
                        year, 
                        into = c("century", "year"), 
                        sep = 2, 
                        convert = TRUE)
cases_split
```

Notre nouvel objet `cases_split` contient maintenant 2 nouvelles colonnes de nombres entiers, l'une contenant le siècle, l'autre contenant l'année.

La fonction `unite()` fait exactement le contraire : elle fusionne 2 colonnes existantes en accolant leurs contenus (et en ajoutant un séparateur) :

```{r}
unite(cases_split, new, century, year)
```

La colonne `new` a été créée par la fusion des colonnes `century` et `year` du tableau `cases_split`. Si l'on souhaite supprimer le tiret, il nous faut le spécifier explicitement :

```{r}
unite(cases_split, new, century, year, sep = "")
```


### Exercices {#sec-exo-9}

Examinez les tableaux `rates`, `storms` et `population` du package `EDAWR`.

1. Ces tableaux sont-ils des "tableaux rangés" (tidy data) ?
2. Si oui, quelles sont les variables représentées ?
3. Si non, transformez-les en "tableaux rangés".



## Importer des données depuis un tableur

### Les règles de base

Jusqu'à maintenant, nous avons travaillé exclusivement avec des jeux de données déjà disponibles dans `R`. La plupart du temps, les données sur lesquelles vous devrez travailler devront au préalable être importées dans `R` ou `RStudio`, à partir de fichiers issus de tableurs. De tels fichiers se présentent généralement sous l'un des 2 formats suivants :

1. Fichiers au format `.csv` : il s'agit d'un format de fichier dit "texte brut", c'est à dire qu'il peut être ouvert avec n'importe quel éditeur de texte, y compris le bloc notes de Windows. L'extension `.csv` est l'abréviation de *Comma Separated Values*, autrement dit, dans ce type de fichiers, les colonnes sont séparées par des virgules. Cela peut poser problème en France puisque le symbole des décimales est souvent aussi la virgule (et non le point comme dans les pays anglo-saxons). Le séparateur de colonnes utilisé en France dans les fichiers `.csv` est alors souvent le point-virgule. Il est possible de créer des fichiers `.csv` à partir de n'importe quel tableur en choisissant `Fichier > Exporter...` ou `Fichier > Enregistrer sous...` puis en sélectionnant le format approprié (les dénominations sont variables selon les logiciels : format texte brut, format csv, plain text, etc...).
2. Fichiers au format tableur : `.xls` ou `.xlsx` pour Excel, `.calc` pour Open Office.

Dans les 2 cas, pour que `R` puisse importer les données contenues dans ces fichiers, un certain nombre de règles doivent être respectées : 

1. La première chose à laquelle il faut veiller est la présentation des données. Les variables doivent être en colonnes et les observations en lignes. Dans l'idéal, les données doivent donc être "rangées".
2. Les cases vides qui correspondent à des données manquantes doivent contenir les lettres `NA` en majuscule. Il est important de bien faire la distinction entre les vrais zéros (*i.e.* les grandeurs mesurées pour lesquelles un zéro a été obtenu), et les valeurs manquantes, c'est à dire pour lesquelles aucune valeur n'a pu être obtenue (*e.g.* variable non mesurée pour un individu donné ou à une station donnée).
3. Il est généralement conseillé d'utiliser la première ligne du tableau pour stocker le nom des variables.
4. Pour les noms de fichiers, de colonnes ou dans le contenu des colonnes, il vaut mieux éviter les caractères spéciaux tels que #, $, %, ^, &, \*, (, ), {, }, [, ], \\, /, les accents, cédilles, guillemets ou apostrophes... Cela pourrait causer des erreurs dans `R`. Si votre fichier en contient, faites une recherche (*via* le menu `Edition > Rechercher et remplacer...`) pour remplacer chaque instance par un caractère qui ne posera pas de problème.
5. Évitez les espaces dans vos noms de variables, d'observations ou de catégories et remplacez-les par des points ou, de préférence, des tirets bas `_`.
6. Si des noms de lignes sont présents dans votre tableau, chaque ligne doit avoir un nom unique (il ne faut pas que plusieurs lignes portent le même nom).
7. Des noms courts pour les variables sont généralement plus faciles à manipuler par la suite.
8. La première valeur de votre tableau devrait toujours se trouver dans la cellule A1 du tableur. Autrement dit, il ne devrait jamais y avoir de lignes incomplètes ou de lignes de commentaires au-dessus des données, ou de colonne vide à gauche de votre tableau. D'ailleurs, il ne devrait jamais y avoir de commentaires à droite ou en dessous de vos données non plus.

:::{.callout-important}
## Différence de philosophie

Quand on travaille dans un tableur, on double clique sur le nom du fichier pour l'ouvrir dans le logiciel approprié (Excel par exemple), puis on en modifie ensuite le contenu en ajoutant ou supprimant des cellules, en modifiant des données déjà existantes ou en créant des graphiques par exemple. Les modifications sont en général sauvegardées au fur et à mesure, manuellement ou automatiquement. Au final, le fichier de départ a été modifié : son contenu n'est plus le même après votre séance de travail et il est virtuellement impossible de garder la trace de toutes les opérations qui ont été effectuées lors de la séance de travail.

Lorsqu'on importe des données issues d'un tableur dans `R` ou `RStudio`, la philosophie est totalement différente : les données sont copiées dans la mémoire vive de l'ordinateur au moment de l'importation, et on ne travaille donc pas directement dans le fichier de données. On travaille dans `RStudio` pour mettre en forme les données, ajouter ou modifier des variables, faire des graphiques et des tests statistiques, **en tapant des commandes dans un script**. À aucun moment le fichier tableur de départ n'est modifié, à aucun moment son contenu n'est altéré. Tout le travail que l'on effectue sur les données importées n'existe que :

1. dans la mémoire vive de l'ordinateur, 
2. et sous la forme de commandes tapées dans un script. 

Pour sauvegarder notre travail, on enregistre notre script. À la prochaine session de travail, nous n'aurons plus qu'à ré-ouvrir notre script dans `RStudio`, puis à ré-envoyer dans la console la totalité des commandes qu'il contient. Ainsi, les données du fichier tableur seront ré-importées puis toutes les analyses seront exécutées à nouveau et on pourra reprendre le travail là où on l'avait laissé. Cela présente le très gros avantage de ne jamais modifier les données brutes contenues dans le fichier de départ. En outre, un script ne contient en général que quelques centaines de lignes de code au format texte brut. Cela en fait des fichiers très peu volumineux qu'il est facile de dupliquer, modifier, échanger, etc. Ils contiennent la trace de toutes les modifications et opérations que nous faisons subir aux données, ce qui en fait un outil indispensable pour la **reproductibilité des analyses**.
:::


### Fichiers au format tableur (.xls ou .xlsx) {#sec-tableur}

À titre d'exemple, téléchargez le fichier [dauphin.xls](data/dauphin.xls) et placez-le dans votre répertoire de travail. Ce jeu de données contient des résultats de dosages de différents métaux lourds (cadmium, cuivre et mercure) dans différents organes (foie et rein) de plusieurs dauphins communs *Delphinus delphis*. Les informations de taille, d'âge et de statut reproducteur sont également précisées. Ouvrez ce fichier dans un tableur. Vous constaterez que son format ne permet pas de l'importer tel quel dans `R` :

- Il contient des lignes vides inutiles au-dessus des données.
- Il contient des commentaires inutiles au-dessus des données.
- Les titres de colonnes sont complexes et contiennent des caractères spéciaux.
- Dans le tableau, les données manquantes sont représentées soit par des "`*`", soit par des cellules vides.

Importer un tel jeu de données dans `R` par les méthodes classiques (c'est-à-dire sans utiliser `RStudio` et uniquement grâce aux fonctions de base de `R`) demanderait donc un gros travail de mise en forme préalable. Heureusement, `RStudio` et le package `readxl` facilitent grandement le processus.

Dans `RStudio`, localisez l'onglet `Files` situé dans le panneau en bas à droite de l'interface du logiciel. Dans ce panneau, naviguez jusqu'à votre répertoire de travail, qui doit maintenant contenir le fichier `daupin.xls` que vous avez téléchargé. Cliquez sur son nom, puis, dans le menu qui s'affiche, choisissez `Import Dataset...` :

```{r}
#| label: fig-import
#| echo: false
#| out-width: '70%'
#| fig-align: 'center'
#| fig-cap: "L'option `Import Dataset...` dans la fenêtre `Files` de `RStudio`."

knitr::include_graphics('images/import.png')
```

La nouvelle fenêtre qui s'ouvre est celle de l'*assistant d'importation* (@fig-import2).

```{r}
#| label: fig-import2
#| echo: false
#| out-width: '100%'
#| fig-align: 'center'
#| fig-cap: "L'assistant d'importation de `RStudio`."

knitr::include_graphics('images/import2.png')
```

Cette fenêtre contient plusieurs zones importantes :

1. `File/URL` (en haut) : lien vers le fichier contenant les données, sur votre ordinateur ou en ligne.
2. `Data Preview` : zone principale affichant les 50 premières lignes du fichier que l'on souhaite importer.
3. `Import Options` (en bas à gauche) : zone dans laquelle des options permettant d'importer les données correctement peuvent être spécifiées.
4. `Code Preview` (en bas à droite) : les lignes de codes que vous pourrez copier-coller dans votre script une fois les réglages corrects effectués.

Ici, nous constatons que les données ne sont pas au bon format. La première chose que nous pouvons faire est d'indiquer à `R` que nous souhaitons ignorer les 9 premières lignes du fichier. Ensuite, nous précisons à RStudio que l'étoile "`*`" a été utilisée pour indiquer des données manquantes (@fig-import3) :

```{r}
#| label: fig-import3
#| echo: false
#| out-width: '100%'
#| fig-align: 'center'
#| fig-cap: "Les bons réglages pour ce fichier."

knitr::include_graphics('images/import3.png')
```

Notez qu'à chaque fois que vous modifiez une valeur dans la zone `Import Options`, 2 choses se produisent simultanément :

1. La zone `Data Preview` est mise à jour. Cela permet de s'assurer que les changements effectués ont bien les effets escomptés.
2. La zone `Code Preview` est mise à jour. Cela permet de copier-coller dans un script les commandes permettant d'importer correctement les données. Ici, voilà le code que nous devons ajouter à notre script :

```{r}
#| label: importscript

dauphin <- read_excel("data/dauphin.xls", na = "*", skip = 9)
```

La commande `library(readxl)` est inutile puisque nous l'avons déjà saisie au début de ce chapitre. Nous disposons maintenant d'un nouvel objet nommé `dauphin`. Il est stocké sous la forme d'un `tibble` :

```{r}
dauphin
```

Notez toutefois que les noms de colonnes complexes sont toujours présents. Avec de tels noms, les variables ne seront pas faciles à manipuler et les risques d'erreurs de frappes seront nombreux. Nous avons tout intérêt à les modifier à l'aide de la fonction `names()` :

```{r}
#| label: namesdauphins

names(dauphin) <- c("ID", "Sexe", "Statut", "Taille",
                    "Age", "Cd", "Cu", "Hg", "Organe")
dauphin
```

Enfin, vous pouvez également noter que certaines variables devraient être modifiées :

- Les variables `Sexe`, `Statut` (qui contient l'information de statut reproducteur des dauphins) et `Organe` (qui indique dans quel organe les métaux ont été dosés) sont de type `<chr>`. L'idéal serait de disposer de facteurs puisqu'ils s'agit de variables catégorielles.
- La variable `ID` est totalement inutile puisqu'elle est parfaitement redondante avec le numéro de ligne. Nous pourrions donc la supprimer.
- Certaines catégories (ou niveaux) de la variable `Statut` devraient être ordonnées puisqu'elles reflètent une progression logique : `imm` (immature), `mat` (mature), `pnl` (pregnant not lactating), `pl` (pregnant lactating), `l` (lactating), `repos` (repos somatique).

Nous verrons dans le @sec-wrangling comment effectuer simplement ces différentes opérations.


### Fichiers au format texte brut (.csv) {#sec-plaintext}

Nous allons utiliser les mêmes données que précédemment, mais cette fois-ci, elles sont contenues dans un fichier au format `.csv`. Téléchargez le fichier [dauphin.csv](data/dauphin.csv) (pour cela, faites un clic droit sur le lien et choisissez `Enregistrez la cible du lien sous...` ou une mention équivalente), placez-le dans votre répertoire de travail, et ouvrez-le avec le bloc notes Windows ou tout autre éditeur de texte brut disponible sur votre ordinateur. **Attention** : Microsoft Word n'est pas un éditeur de texte brut. Un fichier au format `.doc` ou `.docx` est illisible dans un éditeur de texte brut car outre le texte, ces formats de documents contiennent toutes les informations concernant la mise en forme du texte (polices de caractères, tailles, couleurs et autres attributs, présence de figures, de tableaux dans le document, etc.).

À l'inverse, les fichiers au format `.txt`, `.csv`, `.tsv` et même `.R` (vos scripts !) sont des fichiers au format texte brut. Vous pouvez d'ailleurs essayer d'ouvrir `dauphin.csv` depuis `RStudio`, en allant dans la fenêtre `Files` puis en cliquant sur le nom du fichier et en choisissant `View File`. `RStudio` ouvre un nouvel onglet à côté de votre script vous permettant d'inspecter le contenu de ce fichier. Par rapport au fichier Excel, vous pouvez noter un certain nombre de différences : 

1. Les colonnes sont séparées par des tabulations (il aurait pu s'agir de virgules, de points-virgules, d'un caractère spécial ou de simples espaces).
2. Les nombres décimaux utilisent la virgule (et non le point comme dans les pays anglo-saxons).
3. Les noms de colonnes ont déjà été corrigés/simplifiés par rapport au tableau d'origine.
4. Les valeurs manquantes sont toutes codées par des `NA`s.

Un travail d'édition du fichier `.xls` de départ a donc été réalisé en amont de l'enregistrement au format `.csv`.

Attention, à ce stade, vous avez ouvert un fichier au format texte brut dans `RStudio`, mais les données contenues dans ce fichier n'ont pas été importées dans `R` pour autant. Pour les importer, on procède comme pour les fichiers au format tableur (voir @sec-tableur ci-dessus).

On commence par cliquer sur `dauphin.csv` dans l'onglet `Files` de `RStudio.` On sélectionne ensuite `Import Dataset...` :

```{r}
#| label: fig-importcsv1
#| echo: false
#| out-width: '80%'
#| fig-align: 'center'
#| fig-cap: "Importer un fichier `.csv` depuis l'onglet `Files` de `RStudio`."

knitr::include_graphics('images/importcsv1.png')
```

La fenêtre qui s'ouvre est en tous points identique à celle obtenue pour l'importation de fichiers tableurs (@fig-importcsv2).

```{r}
#| label: fig-importcsv2
#| echo: false
#| out-width: '100%'
#| fig-align: 'center'
#| fig-cap: "Importer un fichier `.csv` depuis l'onglet `Files` de `RStudio`."

knitr::include_graphics('images/importcsv2.png')
```

Nous voyons ici que par défaut, `RStudio` considère qu'une unique colonne est présente. En effet, les fichiers `.csv` utilisent généralement la virgule pour séparer les colonnes. Ce n'est pas le cas ici. Il nous faut donc sélectionner, dans le champ `Delimiter`, l'option `Tab` (tabulation) et non `Comma` (virgule).

À ce stade, chaque variable est maintenant reconnue comme telle, chaque variable occupe donc une colonne distincte. Mais les colonnes `Cd`, `Cu` et `Hg` ne contiennent pas les bonnes valeurs (vous pouvez le vérifier en consultant l'onglet `dauphin.csv` que vous avez ouvert un peu plus tôt à côté de votre script). La cause est simple : `R` s'attend à ce que les nombres décimaux utilisent le point en guise de symbole des décimales. Or, notre fichier `.csv` utilise la virgule. C'est une convention qui dépend du pays dans lequel vous vous trouvez, et de la langue de votre système d'exploitation (en langage technique, on parle de `Locale`). Le fichier `dauphin.csv` ayant été créé sur un ordinateur français, la virgule a été utilisée en guise de symbole des décimales. Pour l'indiquer à `R`, cliquez sur `Locale > Configure...`, changez le `.` en `,` dans le champ `Decimal Mark` et validez en cliquant sur `Configure`.

```{r}
#| label: fig-importcsv3
#| echo: false
#| out-width: '50%'
#| fig-align: 'center'
#| fig-cap: "Changement du symbole utilisé pour les décimales."

knitr::include_graphics('images/importcsv3.png')
```

Les données sont maintenant au bon format, prêtes à être importées dans `RStudio.` Afin de ne pas écraser l'objet `dauphin` que nous avons créé à partir du fichier tableur un peu plus tôt, nous stockerons ces nouvelles données dans un objet nommé `dauphin2`. Pour cela, ajoutez un `2` au nom `dauphin` dans le champ `Name` en bas à gauche :

```{r}
#| label: fig-importcsv4
#| echo: false
#| out-width: '100%'
#| fig-align: 'center'
#| fig-cap: "Les données, dans un format correct permettant l'importation."

knitr::include_graphics('images/importcsv4.png')
```

Nous n'avons plus qu'à copier-coller dans notre script le code généré automatiquement en bas à droite de la fenêtre. Comme précédemment, la ligne `library(readr)` est inutile : ce fait package fait partie du `tidyverse` et nous l'avons donc déjà chargé en début de chapitre.

```{r}
dauphin2 <- read_delim("data/dauphin.csv", 
                       "\t", escape_double = FALSE, 
                       locale = locale(decimal_mark = ","), 
                       trim_ws = TRUE)
```

Notez que :

1. C'est le package `readr` et non plus `readxl` qui est utilisé.
2. La fonction `read_delim()` a remplacé la fonction `read_excel()`. Il existe beaucoup d'autres fonctions selon le format de vos données (par exemple `read_csv()` et `read_csv2()`). Il est inutile de toutes les connaître dans la mesure où généralement, `RStudio` vous propose automatiquement la plus appropriée.
3. `R` indique de quelle façon les colonnes ont été "parsées", autrement dit, `R` indique quelles fonctions ont été utilisées pour reconnaître le type des données présentes dans chaque colonne. 

Toutes les fonctions permettant d'importer des données n'ont pas nécessairement le même comportement. Ainsi, si l'on compare les objets importés depuis le fichier tableur (`dauphin`) et depuis le fichier texte brut (`dauphin2`), le type de certaines variables peut être différent :

```{r}
dauphin
dauphin2
```

En particulier selon la version des packages que vous utilisez et les réglages spécifiques de vos systèmes d'exploitation, les variables `Taille` et `Age` sont parfois considérées comme réelles dans `dauphin` (`<dbl>`) mais comme entières dans `dauphin2` (`<int>`, ce n'est pas le cas ici). Afin d'éviter les confusions dans la suite du document, nous allons supprimer `dauphin2` en tapant :

```{r}
rm(dauphin2)
```

Taper `dauphin2` dans la console devrait maintenant produire une erreur :

```{r}
#| error: true

dauphin2
```

### En cas de problème... {#sec-importproblem}

Il arrive parfois que l'importation de fichiers textes bruts par la méthode décrite ci-dessus échoue en raison d'un bug du package `readr` qui gère mal la présence de caractères spéciaux (accents, cédilles, etc) dans le chemin des fichiers que l'on tente d'importer. À l'heure où j'écris ces lignes, ce bug déjà ancien est toujours présent sur certains systèmes. Il est donc utile de connaître une méthode alternative pour importer de tels fichiers dans `R`. Cette méthode repose sur "la mère de toutes les fonctions d'importation" : `read.table()`.

La fonction `read.table()` est à la base de la plupart des fonctions d'importation décrites dans ce chapitre. Il est donc important d'en connaître la syntaxe et les arguments les plus courants. Cette fonction requiert en général les arguments suivants :

1. Le chemin du fichier texte contenant les données à importer. Si le fichier se trouve dans votre répertoire de travail, il suffit de donner son nom. S'il est dans un sous-dossier de votre répertoire de travail, il faut donner le nom complet : `"sous_dossier/nom_du_fichier.csv"`.
2. `sep` : la spécification du symbole utilisé en guise de séparateur de colonnes dans le fichier texte. Cela peut-être la virgule (`sep = ","`), le point virgule (`sep = ";"`) ou encore la tabulation (`sep = "\t"`) selon les fichiers importés. 
3. `dec` : la spécification du symbole utilisé en guise de symbole pour les décimales. Il n'est pas nécessaire de spécifier cet argument lorsque le symbole dans le fichier source est le point. Mais si c'est une virgule (comme c'est souvent le cas dans les pays francophones), il faut alors préciser `dec = ","`.
4. `header` : la première ligne du fichier source contient-elle des noms de variables. Si oui, il faut indiquer `header = TRUE`.

Ainsi, par exemple, pour le fichier `dauphin.csv` que j'ai placé dans un sous-dossier de mon répertoire de travail nommé `data`, on peut taper ceci :

```{r}
dauph <- read.table("data/dauphin.csv",
                    sep = "\t",
                    dec = ",",
                    header = TRUE)
dauph
```

Puisque la fonction `read.table()` importe les données sous la forme d'un `data.frame`, il est nécessaire de transformer le tableau obtenu en `tibble` grâce à la fonction `as_tibble()` afin de bénéficier de tous les avantages de ce format d'objet.

```{r}
dauph <- as_tibble(dauph)
dauph
```


### Exercices {#sec-exo-10}

1. L'objet `dauphin` est-il "tidy" (autrement dit, s'agit-il de "données rangées") ? Justifiez.
2. Produisez le graphique ci-dessous :
```{r}
#| label: fig-exercicedauphin
#| echo: false
#| warning: false
#| fig-asp: 1
#| fig-cap: "Figure à reproduire."

dauphin |> 
  ggplot(aes(x = Age, y = Hg, color = Sexe)) +
    geom_smooth(method = "lm") +
    geom_point() +
    facet_wrap(~Organe, nrow=2, scales = "free_y") +
    labs(x = "Âge (années)",
         y = "Concentration en mercure (mg/kg)",
         title = "Évolution de la concentration en Hg avec l'âge chez Delphinus delphis",
         color = "Sexe",
         caption = "Données : dauphin.xls") +
    theme_bw()
```
Indice : les droites de régression avec les intervalles de confiance sont ajoutés grâce à la fonction `geom_smooth(method = "lm")`.

3. Importez dans `R` le jeu de données [whoTB.csv](data/whoTB.csv). Ce jeu de données contient les cas de tuberculose (TB) rapportés par l'Organisation Mondiale de la Santé (OMS, ou WHO en anglais : World Health Organization). Les cas sont répertoriés par année, pays, âge, sexe, type de tuberculose et méthode de diagnostique. Selon vous, ce jeu de données est-il "rangé" ? Pourquoi ?
4. Si ce jeu de données n'est pas rangé, rangez-le en utilisant les fonctions du packages `tidyr` que nous avons découvertes dans ce chapitre : `pivot_longer()`, `pivot_wider()`, `separate()` et `unite()`. Vous n'aurez pas nécessairement besoin d'utiliser ces 4 fonctions, et à l'inverse, certaines devront peut-être être utilisées plusieurs fois. 

Pour vous aider, l'OMS donne la signification des codes utilisés en guise de noms pour la plupart des colonnes. Ainsi :

- `new` indique des nouveaux cas, `old` des anciens (ici, seuls des nouveaux cas sont rapportés).
- Le type de cas est précisé ensuite : 
    * `sp` signifie "Smear Positive" (tuberculose pulmonaire à frottis positif).
    * `sn` signifie "Smear Negative" (tuberculose pulmonaire à frottis négatif).
    * `rel` signifie "relapse" (rechute).
    * `ep` signifie "Extra Pulmonary" (tuberculose extra-pulmonaire).
- Le sexe est codé par `m` (male) ou `f` (female).
- Enfin, les chiffres correspondent à des tranches d'âges : 014 signifie "de 0 à 14 ans", "1524" signifie "de 15 à 24 ans", etc.

Dans ces colonnes aux noms composés, les nombres de cas de tuberculose sont rapportés.
